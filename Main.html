<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WeatherNook</title>
    <!-- Bootstrap CSS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Jost:wght@200;300;400&display=swap" rel="stylesheet">
<style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;   
            background-size: cover;
           
        }

        .gif-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .gif-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }


        .weather-box {
            width: 80vw;
            min-width: 80px;
            height: 30vh;
            min-height: 40px;
            border-radius: 30px;
            border-color: rgba(0, 0, 0, 0.1);
            border: 1px;
            border-style: hidden outset outset hidden;
            background: rgba(255, 255, 255, 0.13);       
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;     
        }

     .weather-text {
        color: #ffffff;
        font-family: 'Jost', sans-serif;
        font-size: 30px;
        font-style: normal;
       line-height: normal;  
    }

        .divBg {
        background-image: url("rain.gif");
        background: linear-gradient(187deg,
        #56A0FF 16.39%,
        rgba(124, 192, 255, 0.70) 30.77%,
        rgba(136, 200, 255, 0.71) 56.14%,
        rgba(93, 177, 255, 0.41) 85.83%,
        rgba(86, 174, 255, 0.00) 100%);
        background-size: cover;
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        border-radius: 0px;       
    }

    .InfoMenu {
        margin-top: 130vh;
        margin-left: 10%;
        margin-right: 10%;
        width: 95vw;
        height: 65vh;
        flex-shrink: 0;
        border-radius: 30px;
        background: #1E1E1E;
        background-attachment: fixed;
        background-position: center;
        background-repeat: no-repeat;
        background-size: cover;    
    }

    .UpArrow {
         position: absolute; /* Position relative to the viewport (screen) */
         bottom: -8vh;     /* Position the bottom edge at the vertical center */
        left: 50%;       /* Position the left edge at the horizontal center */
          transform: translate(-50%, -50%); /* Center both horizontally and vertically */
          transition: opacity 0.5s ease;
          padding-top: 10vh;
          opacity: 1;
    }

    section{
            display: grid;
            place-items: center;
            align-content: center;
            max-height: 40vh;
    }

    .hidden {
            opacity: 0;
            transition: all 1s !important;
    }

    .show {
           opacity: 1;
           transition: all 1s !important;
    }

    .spacer {
           margin-top: 50px;
    }

    .weatherStatus{
            margin-right: 80%;
            width: 50px;
            height: 20px;
           position: absolute;
            opacity: 0;

    }
    .weatherMenu {
            margin: 0 auto;
           border-spacing: 20px;
    }

    .weatherMenu td {
            color: #ffffff;
            font-family: 'Jost', sans-serif;
            font-style: normal;
            line-height: normal;
            text-align: justify;  
    }

    .weatherMenu img {
            display: block;
            margin: 0 auto;
    }

    #location-name1 {
            color: #ffffff;
            font-size: 25px;
            font-family: 'Jost', sans-serif;
            font-style: normal;
            line-height: normal;
            text-align: justify;  
}
</style>
</head>

<body>
    <div class="divBg">
        <div class="gifContainer">
            <img src="rain.gif" alt="Rain GIF">
        </div>
   
    <section class="hidden">
        <div class="weather-box">
            <table border="0px">
                <tr>
                    <td  class="weather-text">
                        <object data="/static/thunderstorm_Icon.svg" type="image/svg+xml" height="125px" width="125px" id="weatherIcon1">
                        <img src="fallback-image.png" alt="Fallback image">
                      </object>
                    </td>
                    <td id="temp1" class="weather-text" style="font-size: 75px;">32°</td> 
                </tr>
                <tr>
                    <td id="location-name" class="weather-text" colspan="2">Location Error</td>
                </tr>
            </table>         
        </div>
       </section>

<section class="hidden">
    <div class="weatherStatus hidden">
    <div class="spacer"> </div>
    <table border="0px" >
        <tr>
            <td class="weather-text" style="font-size: 50px; width: 200px;" rowspan="2">
                <object data="/static/thunderstorm_Icon.svg" type="image/svg+xml" height="125px" width="125px" id="weatherIcon2">
                <img src="fallback-image.png" alt="Fallback image">
                </object>
            </td>
            <td id="temp" class="weather-text" style="font-size: 50px; margin: 0; min-width: 200px;">30°C</td>
        </tr>
        <tr>
             <td id="location-name1" style="margin: 0;text-align: left; opacity: 1;">Location Error</td>
        </tr>
    </table>     
    </div>


 <div class="InfoMenu">
        <div class="UpArrow"><svg width="66" height="66" viewBox="0 0 66 66" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g filter="url(#filter0_ddddddd_38_183)">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M33 58C49.0163 58 62 45.0163 62 29C62 12.9837 49.0163 0 33 0C16.9837 0 4 12.9837 4 29C4 45.0163 16.9837 58 33 58ZM33.5481 15.6153C32.7724 15.6153 23.3465 28.8937 24.1222 28.8937H30.8962L31.9155 42.1721C31.9155 42.9054 32.6464 43.4999 33.5481 43.4999C34.4498 43.4999 35.1807 42.9054 35.1807 42.1721L36.0376 28.8937H42.9739C43.9119 28.8937 34.3238 15.6153 33.5481 15.6153Z" fill="url(#paint0_linear_38_183)" shape-rendering="crispEdges"/>
            </g>
            <defs>
            <filter id="filter0_ddddddd_38_183" x="0" y="0" width="66" height="66" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
            <feFlood flood-opacity="0" result="BackgroundImageFix"/>
            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
            <feOffset dy="4"/>
            <feGaussianBlur stdDeviation="2"/>
            <feComposite in2="hardAlpha" operator="out"/>
            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
            <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_38_183"/>
            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
            <feOffset dy="4"/>
            <feGaussianBlur stdDeviation="2"/>
            <feComposite in2="hardAlpha" operator="out"/>
            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
            <feBlend mode="normal" in2="effect1_dropShadow_38_183" result="effect2_dropShadow_38_183"/>
            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
            <feOffset dy="4"/>
            <feGaussianBlur stdDeviation="2"/>
            <feComposite in2="hardAlpha" operator="out"/>
            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
            <feBlend mode="normal" in2="effect2_dropShadow_38_183" result="effect3_dropShadow_38_183"/>
            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
            <feOffset dy="4"/>
            <feGaussianBlur stdDeviation="2"/>
            <feComposite in2="hardAlpha" operator="out"/>
            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
            <feBlend mode="normal" in2="effect3_dropShadow_38_183" result="effect4_dropShadow_38_183"/>
            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
            <feOffset dy="4"/>
            <feGaussianBlur stdDeviation="2"/>
            <feComposite in2="hardAlpha" operator="out"/>
            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
            <feBlend mode="normal" in2="effect4_dropShadow_38_183" result="effect5_dropShadow_38_183"/>
            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
            <feOffset dy="4"/>
            <feGaussianBlur stdDeviation="2"/>
            <feComposite in2="hardAlpha" operator="out"/>
            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
            <feBlend mode="normal" in2="effect5_dropShadow_38_183" result="effect6_dropShadow_38_183"/>
            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
            <feOffset dy="4"/>
            <feGaussianBlur stdDeviation="2"/>
            <feComposite in2="hardAlpha" operator="out"/>
            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
            <feBlend mode="normal" in2="effect6_dropShadow_38_183" result="effect7_dropShadow_38_183"/>
            <feBlend mode="normal" in="SourceGraphic" in2="effect7_dropShadow_38_183" result="shape"/>
            </filter>
            <linearGradient id="paint0_linear_38_183" x1="62" y1="29" x2="5.67308" y2="29" gradientUnits="userSpaceOnUse">
            <stop stop-color="white"/>
            <stop offset="1" stop-color="white" stop-opacity="0.74"/>
            </linearGradient>
            </defs>
            </svg>
        </div>

<table class="weatherMenu" style="opacity: 0;">   
            <tr>
              <td><img src="static/sunrise.png"></td>
              <td><img src="static/sunset.png"></td>
            </tr>
            <tr>
              <td id="sunriseTime">   6:45AM</td>
              <td id="sunsetTime">   7:18PM</td>
            </tr>
            <tr>
                <td><img src="static/lowTemp.png"></td>
                <td><img src="static/highTemp.png"></td>
              </tr>
              <tr>
                <td id="lowTemp">  Min: 27°</td>
                <td id="highTemp">  Max: 34°</td>
              </tr>
              <tr>
                <td><img src="static/wind.png"></td>
                <td><img src="static/humid.png"></td>
              </tr>
              <tr>
                <td id="windSpeed">Wind: 20kph</td>
                <td id="humidity">Humid: 30%</td>
              </tr>
    </table>
    </div>
</section>

<script>
        const observer = new IntersectionObserver((entries) => {
            let isArrowVisible = false;
            let isWeatherBoxVisible = false;
    
            entries.forEach((entry) => {
                if (entry.target.classList.contains('UpArrow') && entry.isIntersecting) {
                    isArrowVisible = true;
                }
    
                if (entry.target.classList.contains('weather-box') && entry.isIntersecting) {
                    isWeatherBoxVisible = true;
                }
            });
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('show');
                    document.querySelector('.UpArrow').style.opacity = '1';
                } else {
                    entry.target.classList.remove('show');
                    document.querySelector('.UpArrow').style.opacity = '0';
                }
            });
        });const upArrow = document.querySelector(".UpArrow");
const weatherStatus = document.querySelector(".weatherStatus");
const weatherMenu = document.querySelector(".weatherMenu");

window.addEventListener('scroll', () => {
    if (window.pageYOffset > 120) {
        upArrow.style.opacity = "0";
        weatherStatus.style.opacity = "1";
        weatherMenu.style.opacity = "1"; // Set opacity to 1 for weatherMenu
    } else {
        upArrow.style.opacity = "1";
        weatherStatus.style.opacity = "0";
        weatherMenu.style.opacity = "0";
    }
});

        const hiddenElements = document.querySelectorAll('.hidden');
        hiddenElements.forEach((el) => observer.observe(el));

// Declare city as a global variable

/*
let city = '';
console.log(city);
const openCageApiKey = 'c50db7640d3f49e89e76e7effb65fe5d';

if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(successCallback, fallbackToIPBasedLocation, { timeout: 10000 });
} else {
    fallbackToIPBasedLocation();
}

function successCallback(position) {
    const latitude = position.coords.latitude.toFixed(2);
    const longitude = position.coords.longitude.toFixed(2);

    fetch(`https://api.opencagedata.com/geocode/v1/json?q=${latitude}+${longitude}&key=${openCageApiKey}`)
        .then(response => response.json())
        .then(data => {
            city = data.results[0].components.city;
            // Call sendCityToBackend(city) after city is updated
            sendCityToBackend(city);
            console.log(city);
            console.log("Data from Opencage")
        })
        .catch(error => {
            console.log('Error fetching location:', error);
            console.log('Unable to determine city.');
        });
}
*/

let city = '';
console.log(city);
const mapboxApiKey = 'pk.eyJ1IjoiY3V0aWVjYXQiLCJhIjoiY2xyYnk5ZmR0MHgwbTJrbGRkaTN1eXJ6ZSJ9.jhNjMxaAq939F-tuP34LqA';

if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(successCallback, fallbackToIPBasedLocation, { timeout: 10000 });
} else {
    fallbackToIPBasedLocation();
}

function successCallback(position) {
    const latitude = position.coords.latitude.toFixed(2);
    const longitude = position.coords.longitude.toFixed(2);

    fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${longitude},${latitude}.json?access_token=${mapboxApiKey}`)
        .then(response => response.json())
        .then(data => {
            if (data.features.length > 0) {
                city = data.features[0].context.find(context => context.id.includes('place')).text;
                // Call sendCityToBackend(city) after city is updated
                sendCityToBackend(city);
                console.log(city);
                console.log("Data from Mapbox API")
            } else {
                console.log('Error fetching location:', data.message);
                console.log('Unable to determine city.');
            }
        })
        .catch(error => {
            console.log('Error fetching location:', error);
            console.log('Unable to determine city.');
        });
}


function fallbackToIPBasedLocation() {
    fetch('https://ipinfo.io/json')
        .then(response => response.json())
        .then(data => {
            city = data.city;
            // Call sendCityToBackend(city) after city is updated
            sendCityToBackend(city);
            console.log("Data from IP info")
        })
        .catch(error => {
            console.log('Error fetching IP-based location:', error);
            console.log('Unable to determine city.');
        });
}
// Function to update temperature in the DOM
function updateTemperature(temperature) {
    const temperatureElement = document.getElementById('temp');
    const temperatureElement1 = document.getElementById('temp1');

    if (temperatureElement && temperatureElement1) {
        temperatureElement.innerText = `${temperature}°C`;
        temperatureElement1.innerText = `${temperature}°`;
    } else {
        console.error('Temperature elements not found.');
    }
}

// Function to send city to backend
async function sendCityToBackend(city) {
    try {
        const response = await fetch('/weather', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ city }),
        });

        if (!response.ok) {
            throw new Error(`Error: ${response.statusText}`);
        }

        // Handle the response as needed
        const data = await response.json();
        console.log(data);

        // Handle the city data
        handleCityData(data);
    } catch (error) {
        console.error(`Error sending city to the backend: ${error}`);
    }
}

// Function to handle city data received from the backend
function handleCityData(data) {
    const city = data.city;
    const sunriseTime = data.sunrise_time;
    const sunsetTime = data.sunset_time;
    const minTemperature = data.min_temperature;
    const maxTemperature = data.max_temperature;
    const windSpeed = data.wind_speed;
    const humidity = data.humidity;
    const temperature = data.temperature;
    const description = data.description;

    // Update the location name element with the received city
    updateLocationName(city);
    // Update the sunrise and sunset time elements
    updateSunriseAndSunsetTime(sunriseTime, sunsetTime);
    // Update the temperature elements with the received values
    updateTemperature(temperature);
    // Update the min and max temperature elements
    updateMinAndMaxTemperature(minTemperature, maxTemperature);
    // Update the wind speed and humidity elements
    updateWindSpeedAndHumidity(windSpeed, humidity);
    updateDescription(description);
    console.log("Description received:", description); 
    // Check if the description is "snow", "clear", or "clouds"
        if (['snow', 'clear', 'clouds'].includes(description.toLowerCase())) {
        // If it is, find the gif container and remove it
        const gifContainer = document.querySelector('.gifContainer');
        if (gifContainer) {
            gifContainer.remove();
        }
    }

}

// Function to update sunrise and sunset time in the DOM
function updateSunriseAndSunsetTime(sunriseTime, sunsetTime) {
    const sunriseElement = document.getElementById('sunriseTime');
    const sunsetElement = document.getElementById('sunsetTime');

    if (sunriseElement && sunsetElement) {
        sunriseElement.innerText = `${sunriseTime}`;
        sunsetElement.innerText = `${sunsetTime}`;
    } else {
        console.error('Sunrise and sunset time elements not found.');
    }
}
// Function to update location name in the DOM
function updateLocationName(city) {
    const locationElement = document.getElementById('location-name');
    const locationElement1 = document.getElementById('location-name1');

    if (locationElement && locationElement1) {
        locationElement.innerText = city;
        locationElement1.innerText = city; // Update location-name1 as well
    } else {
        console.error('Location name elements not found.');
    }
}

// Function to update min and max temperature in the DOM
function updateMinAndMaxTemperature(minTemperature, maxTemperature) {
    const minTempElement = document.getElementById('lowTemp');
    const maxTempElement = document.getElementById('highTemp');

    if (minTempElement && maxTempElement) {
        minTempElement.innerText = `Min: ${minTemperature}°`;
        maxTempElement.innerText = `Max: ${maxTemperature}°`;
    } else {
        console.error('Min and max temperature elements not found.');
    }
}
// Function to update wind speed and humidity in the DOM
function updateWindSpeedAndHumidity(windSpeed, humidity) {
    const windSpeedElement = document.getElementById('windSpeed');
    const humidityElement = document.getElementById('humidity');

    if (windSpeedElement && humidityElement) {
        windSpeedElement.innerText = `Wind: ${windSpeed}kph`;
        humidityElement.innerText = `Humidity: ${humidity}%`;
    } else {
        console.error('Wind speed and humidity elements not found.');
    }
}

sendCityToBackend(city);

let nightFlag = 0;
    function updateBackgroundBasedOnTime() { //This is measier than my life damn
    // Get the current hour
    const currentHour = new Date().getHours();
    // Define the start and end of the "night" period
    const nightStart = 18; // 6 PM
    const nightEnd = 6; // 6 AM
    // Get the body and divBg elements
    const bodyElement = document.querySelector('body');
    const divBgElement = document.querySelector('.divBg');

    // If it's night time...
    if (currentHour >= nightStart || currentHour < nightEnd) {
        // Change the body background color
        bodyElement.style.backgroundColor = 'rgb(10, 64, 114)';
        nightFlag = 1;
        // Change the divBg background
        divBgElement.style.background = 'linear-gradient(187deg, #002444 16.39%, rgb(1, 31, 61) 30.77%, rgba(0, 30, 55, 0.829) 56.14%, rgba(14, 63, 108, 0.811) 85.83%, rgb(10, 64, 114) 100%)';
    } else {
        // Otherwise, reset the backgrounds to their original values
        bodyElement.style.backgroundColor = ''; // replace with original color
        divBgElement.style.background = ''; // replace with original gradient
        nightFlag = 0;
    }
}

// Call the function immediately, and then every hour
updateBackgroundBasedOnTime();
setInterval(updateBackgroundBasedOnTime, 60 * 60 * 1000);


function updateDescription(description) { //description is literally on the json read it!!!
    // Check if description is a string
    if (typeof description !== 'string') {
        console.error('Invalid description:', description);
        return;
    }

    const descElement = document.getElementById('desc');
    const iconElement1 = document.getElementById('weatherIcon1');
    const iconElement2 = document.getElementById('weatherIcon2');

    // Check if the description contains the word "clouds"
    if (description.toLowerCase().includes('clouds') && nightFlag == 0) {
        // If yes, update the image source to cloudy.svg for both icons
        iconElement1.data = '/static/cloudy.svg';
        iconElement2.data = '/static/cloudy.svg';
    } 
    
    else if (description.toLowerCase().includes('snow') && nightFlag == 0) {
        // If yes, update the image source to cloudy.svg for both icons
        iconElement1.data = '/static/snow.svg';
        iconElement2.data = '/static/snow.svg';
    } 

    else if (description.toLowerCase().includes('clear') && nightFlag == 1) {
        // If yes, update the image source to cloudy.svg for both icons
        iconElement1.data = 'static/clearNight.svg';
        iconElement2.data = 'static/clearNight.svg';
    } 

    else if (description.toLowerCase().includes('clouds') && nightFlag == 1) {
        // If yes, update the image source to cloudy.svg for both icons
        iconElement1.data = 'static/partlyCloudyNight.svg';
        iconElement2.data = 'static/partlyCloudyNight.svg';
    } 
        
    else {
        // Otherwise, keep the original id and image sources
        iconElement1.data = '/static/thunderstorm_Icon.svg';
        iconElement2.data = '/static/thunderstorm_Icon.svg';
    }

}


</script>
    

    <!-- Bootstrap JS and Popper.js (optional) -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
